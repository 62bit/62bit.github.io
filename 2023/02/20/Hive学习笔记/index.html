<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Hive学习笔记 | 62bit的秘密基地</title><meta name="author" content="62bit"><meta name="copyright" content="62bit"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据仓库和数据库的区别 用途： 数据库主要用于事务处理，即对数据进行增删改查等操作，支持在线应用和实时查询； 数据仓库主要用于数据分析，即对数据进行汇总、统计、挖掘等操作，支持离线批处理和复杂查询。   数据： 数据库存储的是当前的、细节的、原始的业务数据，通常是面向应用的； 数据仓库存储的是历史的、汇总的、清洗过的分析数据，通常是面向主题的。   结构： 数据库采用范式化（Normalized）">
<meta property="og:type" content="article">
<meta property="og:title" content="Hive学习笔记">
<meta property="og:url" content="http://example.com/2023/02/20/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="62bit的秘密基地">
<meta property="og:description" content="数据仓库和数据库的区别 用途： 数据库主要用于事务处理，即对数据进行增删改查等操作，支持在线应用和实时查询； 数据仓库主要用于数据分析，即对数据进行汇总、统计、挖掘等操作，支持离线批处理和复杂查询。   数据： 数据库存储的是当前的、细节的、原始的业务数据，通常是面向应用的； 数据仓库存储的是历史的、汇总的、清洗过的分析数据，通常是面向主题的。   结构： 数据库采用范式化（Normalized）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/favicon.png">
<meta property="article:published_time" content="2023-02-20T11:43:25.000Z">
<meta property="article:modified_time" content="2023-03-28T10:55:05.245Z">
<meta property="article:author" content="62bit">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/favicon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/02/20/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 62bit","link":"链接: ","source":"来源: 62bit的秘密基地","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Hive学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-28 18:55:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="62bit的秘密基地"><span class="site-name">62bit的秘密基地</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Hive学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-20T11:43:25.000Z" title="发表于 2023-02-20 19:43:25">2023-02-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-28T10:55:05.245Z" title="更新于 2023-03-28 18:55:05">2023-03-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Hive学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据仓库和数据库的区别"><a href="#数据仓库和数据库的区别" class="headerlink" title="数据仓库和数据库的区别"></a>数据仓库和数据库的区别</h1><ul>
<li>用途：<ul>
<li>数据库主要用于事务处理，即对数据进行增删改查等操作，支持在线应用和实时查询；</li>
<li>数据仓库主要用于数据分析，即对数据进行汇总、统计、挖掘等操作，支持离线批处理和复杂查询。</li>
</ul>
</li>
<li>数据：<ul>
<li>数据库存储的是当前的、细节的、原始的业务数据，通常是面向应用的；</li>
<li>数据仓库存储的是历史的、汇总的、清洗过的分析数据，通常是面向主题的。</li>
</ul>
</li>
<li>结构：<ul>
<li>数据库采用范式化（Normalized）的表结构，遵循数据库三大范式，减少冗余和异常，提高存储效率和一致性；</li>
<li>数据仓库采用反范式化（Denormalized）或多维（Dimensional）的表结构，增加冗余和索引，提高查询效率和易用性。</li>
</ul>
</li>
<li>优化：<ul>
<li>数据库对读写都有优化，需要保证事务的原子性、一致性、隔离性和持久性（ACID）；</li>
<li>数据仓库只对读有优化，不需要保证ACID，但需要保证可扩展性和容错性。</li>
</ul>
</li>
</ul>
<h2 id="反范式化的表结构（Denormalized）"><a href="#反范式化的表结构（Denormalized）" class="headerlink" title="反范式化的表结构（Denormalized）"></a>反范式化的表结构（Denormalized）</h2><p>反范式化或多维的表结构是指在数据仓库中，为了提高查询效率和易用性，而选择性地违反范式化规则，增加冗余数据或者对维度表进行层次化的设计方式。</p>
<p>反范式化有两种常见的方式：Rolldown和Rollup</p>
<ul>
<li>Rolldown是将父实体中的所有列和关系都下沉到子实体中，消除了表之间的连接，但增加了数据冗余。</li>
<li>Rollup是将子实体中的内容保留在父实体中，减少了数据存储量，但需要指定子实体出现的次数。</li>
</ul>
<h2 id="多维表结构"><a href="#多维表结构" class="headerlink" title="多维表结构"></a>多维表结构</h2><p>多维的表结构是指将数据按照事实表和维度表进行划分，并根据不同的业务需求，采用星型模式、雪花模式或星座模式来组织表之间的关系。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zuochang_liu/article/details/108573410">全方位解读星型模型,雪花模型及星座模型_星型模型 雪花模型 星座模型_</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44556829/article/details/124117607">一图搞懂多维数据模型各种类型（星型、雪花、星座、交叉连接）</a></p>
<h1 id="Hive的出现解决了什么问题"><a href="#Hive的出现解决了什么问题" class="headerlink" title="Hive的出现解决了什么问题"></a>Hive的出现解决了什么问题</h1><ul>
<li>降低了对海量数据进行分析和处理的难度，提供了类SQL的查询语言HiveQL，使得不熟悉MapReduce编程的用户也可以方便地使用Hadoop。</li>
<li>为HDFS上的文件添加了schema信息，使得数据可以结构化，并且支持多种存储格式。</li>
<li>提供了元数据管理和统一的接口，方便用户对数据进行管理和访问。</li>
<li>支持多种计算引擎，如MapReduce、Spark和Tez，提高了执行效率。</li>
</ul>
<h1 id="Hive的架构"><a href="#Hive的架构" class="headerlink" title="Hive的架构"></a>Hive的架构</h1><p>Hive的架构是基于Hadoop的数据仓库工具，它可以将结构化的数据文件映射为一张数据库表，并提供类SQL的查询语言HQL来对数据进行分析和管理。</p>
<p>架构：</p>
<ul>
<li>用户接口：提供了CLI（命令行）、JDBC&#x2F;ODBC（Java访问）、WebUI（浏览器访问）等方式来连接和操作Hive。</li>
<li>元数据存储中心MetaStore：存储了表名、列名、分区字段、数据类型、数据位置等信息，可以使<strong>用MySQL等数据库来存储元数据</strong>。</li>
<li>驱动器Driver：负责接收用户的HQL语句，进行解析、编译、优化和执行，并生成物理执行计划（通常是MapReduce任务）。<ul>
<li>解析器：使用Calcite框架，将Sql解析，确定执行顺序</li>
<li>编译器：将SQL翻译成一份逻辑计划</li>
<li>优化器：对逻辑计划调优</li>
<li>执行器：将调优后的逻辑计划转为物理计划，提交到yarn上执行</li>
</ul>
</li>
</ul>
<h2 id="为什么不把hive的元数据信息保存在hdfs上"><a href="#为什么不把hive的元数据信息保存在hdfs上" class="headerlink" title="为什么不把hive的元数据信息保存在hdfs上"></a>为什么不把hive的元数据信息保存在hdfs上</h2><p>因为hdfs是一个分布式文件系统，它主要用来存储大规模的数据文件，而不是结构化的元数据。hdfs不支持随机读写，事务，索引等功能，这些功能对于元数据的管理和查询是很重要的。使用关系型数据库来保存hive的元数据，可以提高元数据的可靠性，一致性和效率。</p>
<h1 id="分桶表、分区表、内部表和外部表"><a href="#分桶表、分区表、内部表和外部表" class="headerlink" title="分桶表、分区表、内部表和外部表"></a>分桶表、分区表、内部表和外部表</h1><h2 id="分桶表"><a href="#分桶表" class="headerlink" title="分桶表"></a>分桶表</h2><p>hive分桶表是一种在hive中进一步划分数据的方式，它可以按照某个字段的hash值将数据分散到不同的文件中，这些文件称为桶。</p>
<p>hive分桶表的作用有以下几点：</p>
<ul>
<li>可以进行抽样查询，只扫描部分桶中的数据，提高开发效率。</li>
<li>可以优化大表和大表之间的join操作，使用map端join（Sort Merge Bucket Map Join）代替reduce端join，减少shuffle开销和内存压力。</li>
</ul>
<p>创建hive分桶表需要注意以下几点：</p>
<ul>
<li>需要在建表语句中使用clustered by和into buckets指定分桶字段和分桶个数。</li>
<li>需要在会话终端开启hive.enforce.bucketing&#x3D;true参数，让hive支持分桶操作。</li>
<li>需要使用insert overwrite table或insert into table语句将原始数据插入到分桶表中，不能使用load data语句。</li>
<li>分桶字段必须是建表中已有的字段，并且最好是经常参与join操作的字段。</li>
</ul>
<h3 id="为什么分桶可以提高join效率"><a href="#为什么分桶可以提高join效率" class="headerlink" title="为什么分桶可以提高join效率"></a>为什么分桶可以提高join效率</h3><p>如果两个表join的时候，两个表都是分桶表，并且分桶的字段和个数相同，那么就可以只对相同的桶进行join操作，而不需要对整个表进行扫描和shuffle。这样可以减少数据传输和计算量，提高join的效率。另外，如果一个表很小，可以存储在内存中，那么可以使用map join的方式，在map端直接完成join操作，省去reduce过程。</p>
<h3 id="先后分桶和组合分桶"><a href="#先后分桶和组合分桶" class="headerlink" title="先后分桶和组合分桶"></a>先后分桶和组合分桶</h3><p><strong>Hive在执行HQL语句时是根据分桶个数和分桶字段的可能取值来判断先后分桶和组合分桶的。</strong>如果分桶个数是每个字段的乘积，那么就可以实现先后分桶的效果，否则就是按照多个字段的组合进行分桶的效果。</p>
<p>例子：</p>
<ul>
<li><p>先后分桶：</p>
<p>如果有两个字段ID和Name，ID的可能取值有2个（1和2），Name的可能取值也有2个（A和B），那么每个字段的乘积就是2乘以2，等于4。如果按照ID和Name分桶，且分桶个数设置为4，那么就可以实现先后分桶的效果。也就是先按照ID分为两个桶，再在每个桶中按照Name分两个桶。</p>
</li>
<li><p>组合分桶：</p>
<p>如果ID和Name的可能取值的乘积不止为4，那么会将这两个字段组合起来取hash值分桶。</p>
</li>
</ul>
<h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><p>hive分区表是一种在hive中按照某个或某些字段将数据划分到不同的子目录中的方式，这些子目录称为分区。</p>
<p>hive分区表的作用有以下几点：</p>
<ul>
<li>可以将数据按照逻辑进行组织，比如按照日期、地域等进行分层存储。</li>
<li>可以在查询时通过where子句指定分区条件，只扫描部分分区中的数据，提高查询效率。</li>
<li>可以对不同的分区采用不同的压缩格式或存储格式，节省存储空间和网络传输开销。</li>
</ul>
<p>创建hive分区表需要注意以下几点：</p>
<ul>
<li>需要在建表语句中使用partitioned by指定分区字段和数据类型。</li>
<li>分区字段不能是建表中已有的字段，并且最好是经常作为过滤条件的字段。</li>
<li>需要使用alter table add partition或insert into table语句添加新的分区，不能使用load data语句。</li>
<li>分区表可以有一个或多个分区字段，形成单级或多级分区。</li>
</ul>
<h3 id="分区字段和数据字段"><a href="#分区字段和数据字段" class="headerlink" title="分区字段和数据字段"></a>分区字段和数据字段</h3><p>例子：</p>
<p>创建一个按年月分区的表，可以使用以下语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建动态分区表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> dp_tmp (</span><br><span class="line">  uid <span class="type">int</span> ,</span><br><span class="line">  commentid <span class="type">bigint</span> ,</span><br><span class="line">  recommentid <span class="type">bigint</span></span><br><span class="line">) partitioned <span class="keyword">by</span> ( <span class="keyword">year</span> string, <span class="keyword">month</span> string, <span class="keyword">day</span> string)</span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启动态分区</span></span><br><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition <span class="operator">=</span><span class="literal">true</span> ;</span><br><span class="line"><span class="comment">-- 允许所有的分区字段都可以使用动态分区，兼容严格模式</span></span><br><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition.mode <span class="operator">=</span> nonstrict;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据到分区表</span></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> dp_tmp <span class="keyword">partition</span> ( <span class="keyword">year</span>, <span class="keyword">month</span>, <span class="keyword">day</span> )</span><br><span class="line"><span class="keyword">select</span> uid,commentid,recommentid, <span class="keyword">year</span>, <span class="keyword">month</span>, <span class="keyword">day</span> <span class="keyword">from</span> tmp;</span><br></pre></td></tr></table></figure>

<p>dp_tmp中有六个字段，其中数据字段是uid，commentid和recommentid，分区字段是year，month和day</p>
<p><strong>分区字段不存储实际的数据，而是作为目录名来组织数据。</strong></p>
<p>分区字段和数据字段的区别主要有以下几点：</p>
<ul>
<li>分区字段是用来划分数据的目录结构，而数据字段是用来存储实际的数据内容。</li>
<li>分区字段的值会作为HDFS上的目录名，而数据字段的值会存储在文件中。</li>
<li>分区字段不占用表的存储空间，而数据字段占用表的存储空间。</li>
<li>分区字段可以在查询时作为过滤条件，提高查询效率，而数据字段需要扫描文件进行过滤。</li>
<li>分区字段可以在创建表后动态添加、修改或删除，而数据字段需要在创建表时指定，并且修改或删除需要重建表。</li>
</ul>
<h3 id="静态分区和动态分区"><a href="#静态分区和动态分区" class="headerlink" title="静态分区和动态分区"></a>静态分区和动态分区</h3><p>hive的静态分区和动态分区是两种不同的数据存放方式。静态分区是指在插入数据之前，需要手动创建每个分区，并指定分区值。动态分区是指根据表的输入数据自动创建分区，不需要提前指定分区值。</p>
<p>静态分区和动态分区的区别主要有以下几点：</p>
<ul>
<li>静态分区适用于分区数量少且固定的情况，例如按部门或地区划分。动态分区适用于分区数量多且不确定的情况，例如按时间划分。</li>
<li>静态分区在编译阶段就确定了分区，不需要reduce任务处理，性能较高。动态分区在运行阶段才确定分区，需要reduce任务处理，性能较低。</li>
<li>静态分区不管有没有数据都会创建指定分区，动态分区是有结果集才会创建，否则不创建。</li>
<li>动态分区需要开启相关参数，并设置动态分区的模式。默认是严格模式，表示必须指定至少一个静态分区。非严格模式表示允许所有的分区字段都可以使用动态分区。</li>
<li>动态分区有可能创建大量的分区和文件，对HDFS和Hive的元数据服务造成压力，因此有一些参数限制动态分区的数量和文件的数量。</li>
</ul>
<h2 id="分桶和分区的区别"><a href="#分桶和分区的区别" class="headerlink" title="分桶和分区的区别"></a>分桶和分区的区别</h2><ul>
<li>分区是按照某个字段的值划分数据的存储路径，<strong>每个分区对应一个目录，可以跨越多个文件系统</strong>；分桶是按照某个字段的哈希值划分数据的存储文件，<strong>每个桶对应一个文件，只能在同一个文件系统中</strong>。</li>
<li>分区可以减少扫描的数据量，提高查询效率；分桶可以避免连接和聚合中的shuffle，提高计算效率。</li>
<li>分区可以动态添加或删除，不需要重建表；分桶需要在创建表时指定，如果要修改分桶个数或字段，需要重建表。</li>
<li>分区和分桶可以同时使用，实现更细粒度的数据管理。例如，可以先按照日期分区，再按照用户ID分桶。</li>
</ul>
<h2 id="内部表和外部表"><a href="#内部表和外部表" class="headerlink" title="内部表和外部表"></a>内部表和外部表</h2><ul>
<li>hive内部表由hive管理其元数据和实际数据，而hive外部表只由hive管理其元数据，实际数据由hdfs管理。</li>
<li>hive内部表在创建时不需要使用external关键字，而hive外部表在创建时需要使用external关键字。</li>
<li>hive内部表在删除时会同时删除其元数据和实际数据，而hive外部表在删除时只会删除其元数据，实际数据仍然保留在hdfs上。</li>
<li>hive内部表的存储路径一般是默认的&#x2F;hive&#x2F;warehouse&#x2F;数据库名称&#x2F;表名，而hive外部表的存储路径<strong>一般需要</strong>使用location指定（不是必须指定）。</li>
<li>hive内部表的结构和分区变化会自动同步到元数据，而hive外部表的结构和分区变化则需要使用<code>msck repair table table_name</code>进行修复（因为数据变化后，元数据并没有映射到最新的数据）。</li>
</ul>
<p>一般来说，如果你想让hive完全控制你的数据，并且不需要与其他工具共享数据，你可以使用内部表。如果你想让hdfs管理你的数据，并且需要与其他工具共享数据，你可以使用外部表。</p>
<h2 id="什么时候会用到msck-repair-table-table-name语句"><a href="#什么时候会用到msck-repair-table-table-name语句" class="headerlink" title="什么时候会用到msck repair table table_name语句"></a>什么时候会用到msck repair table table_name语句</h2><p>msck repair table语句主要是用来解决通过hdfs dfs -put或者hdfs api写入hive分区表的数据在hive中无法被查询到的问题。我们知道hive有个服务叫metastore，这个服务主要是存储一些元数据信息，比如数据库名，表名或者表的分区等等信息。如果不是通过hive的insert等插入语句，很多分区信息在metastore中是没有的，如果插入分区数据量很多的话，你用 ALTER TABLE table_name ADD PARTITION 一个个分区添加十分麻烦。这时候 msck repair table 就派上用场了。只需要运行 msck repair table 命令，hive就会去检测这个表在hdfs上的文件，把没有写入metastore的分区信息写入metastore。</p>
<p>一句话：<strong>只要hive表的文件夹的真实状态和元数据信息中存放的状态不一样，就得用msck repair语句</strong></p>
<p><strong>msck repair语句的作用就是让hive表的元数据信息和文件夹的真实状态保持一致。</strong>但是需要注意的是，<strong>msck repair语句只能添加分区信息，不能删除分区信息。</strong>如果你想删除某个分区，你需要用alter table drop partition语句。</p>
<h1 id="Hive表的数据压缩"><a href="#Hive表的数据压缩" class="headerlink" title="Hive表的数据压缩"></a>Hive表的数据压缩</h1><h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><ul>
<li>压缩比：越大越好</li>
<li>压缩时间：越小越好</li>
<li>压缩后的文件是否可切割：如果可切割，在计算阶段可以启动多个mapTask对一个文件进行计算；如果不可切割，要先将大文件拆成多个小文件后分别压缩，然后在计算阶段针对每个小文件启动mapTask</li>
</ul>
<h1 id="Hive表的存储格式"><a href="#Hive表的存储格式" class="headerlink" title="Hive表的存储格式"></a>Hive表的存储格式</h1><h2 id="行式存储"><a href="#行式存储" class="headerlink" title="行式存储"></a>行式存储</h2><p>textFile和sequenceFile</p>
<h2 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h2><p>orc和parquet</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1757862">Hive - ORC 文件存储格式详细解析 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/141908285">再来聊一聊 Parquet 列式存储格式 - 知乎 (zhihu.com)</a></p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>一般来说，行式存储格式和列式存储格式有以下几个方面的区别和优缺点：</p>
<ul>
<li>行式存储格式将一行数据的所有列保存在一起，比较符合面向对象的思维，也比较方便进行插入和更新操作。但是如果查询只涉及某几个列，它会把整行数据都读取出来，不能跳过不必要的列读取。这样会影响查询性能和空间利用率。</li>
<li>列式存储格式将一列数据的所有行保存在一起，比较适合分析型业务，因为它可以只读取需要的列，提高查询效率和压缩比。而且由于每一列的数据类型相同，可以针对性地设计更好的压缩算法。但是如果查询涉及多个列或者需要返回整行数据，它就需要重新组装数据，这样会增加计算开销。而且插入和更新操作也比较麻烦。</li>
</ul>
<p>因此，一般来说，如果你的hive表主要用于存储结构化或半结构化的数据，并且需要频繁地进行插入和更新操作，那么你可以选择行式存储格式，如TEXTFILE或SEQUENCEFILE。如果你的hive表主要用于存储大量的分析型数据，并且需要高效地进行聚合和过滤操作，那么你可以选择列式存储格式，如ORC或PARQUET。</p>
<h1 id="hive中将数据导入一张表中有哪些方法"><a href="#hive中将数据导入一张表中有哪些方法" class="headerlink" title="hive中将数据导入一张表中有哪些方法"></a>hive中将数据导入一张表中有哪些方法</h1><ul>
<li>从本地文件系统中导入数据到Hive表，使用load data local inpath命令，指定本地文件的绝对路径和目标表的名称。</li>
<li>从HDFS上导入数据到Hive表，使用load data inpath命令，指定HDFS文件的路径和目标表的名称。这种方法会删除HDFS上的原始文件。</li>
<li>从别的表中查询出相应的数据并导入到Hive表中，使用insert into table或insert overwrite table命令，指定目标表和分区（如果有的话），以及查询语句。这种方法也适用于分区表和分桶表的情况。</li>
<li>在创建表的时候通过从别的表中查询出相应的记录并插入到所创建的表中，使用create table … as select …命令，指定新建表的名称和结构，以及查询语句。这种方法可以一步完成创建表和导入数据的操作。</li>
</ul>
<h1 id="Hive是怎么把HQL语句转为MR任务的"><a href="#Hive是怎么把HQL语句转为MR任务的" class="headerlink" title="Hive是怎么把HQL语句转为MR任务的"></a>Hive是怎么把HQL语句转为MR任务的</h1><p>Hive把HQL语句翻译成MR任务的大致流程如下：</p>
<ul>
<li>利用Antlr框架定义HQL的语法规则，对HQL完成词法语法解析，将HQL转换为为AST（抽象语法树）；</li>
<li>遍历AST，抽象出查询的基本组成单元QueryBlock（查询块），可以理解为最小的查询执行单元；</li>
<li>遍历QueryBlock，将其转换为OperatorTree（操作树，也就是逻辑执行计划），可以理解为不可拆分的一个逻辑执行单元；</li>
<li>使用逻辑优化器对OperatorTree（操作树）进行逻辑优化。例如合并不必要的ReduceSinkOperator，减少Shuffle数据量；</li>
<li>遍历OperatorTree，转换为TaskTree。也就是翻译为MR任务的流程，将逻辑执行计划转换为物理执行计划；</li>
<li>使用物理优化器对TaskTree进行物理优化；</li>
<li>生成最终的执行计划，提交任务到Hadoop集群运行。</li>
</ul>
<p>具体的MR任务的生成和执行细节可能根据不同的HQL语句和优化策略有所差异。</p>
<h1 id="Hive怎么加快查询速度"><a href="#Hive怎么加快查询速度" class="headerlink" title="Hive怎么加快查询速度"></a>Hive怎么加快查询速度</h1><h2 id="Hive支持索引吗"><a href="#Hive支持索引吗" class="headerlink" title="Hive支持索引吗"></a>Hive支持索引吗</h2><p>mysql中可以创建B+树索引来加快查询速度</p>
<p>Hive也是支持索引的，但是Hive的索引与关系型数据库中的索引并不相同，并且Hive索引提供的功能很有限，效率也并不高，因此Hive索引很少使用。</p>
<p>Hive索引的主要作用是在指定列上建立一个额外的表（索引表），里面包含了该列的值以及对应的数据文件路径和偏移量。在查询时，可以先从索引表中过滤出符合条件的数据文件和偏移量，然后根据这些信息生成新的split，作为查询任务的输入，从而避免全表扫描。</p>
<p>但是Hive索引也有一些缺点和限制，例如：</p>
<ul>
<li>每次查询时都要先用一个额外的job扫描索引表，如果索引列的值非常稀疏或者分布不均匀，那么索引表本身也会非常大或者效果不佳；</li>
<li>索引表不会自动更新，如果原始表有数据新增或删除，那么必须手动重建索引表数据；</li>
<li>索引只适用于静态字段和等值查询，并不能优化范围查询、聚合查询、排序查询等；</li>
<li>索引只能在单个列上创建，并不能创建复合索引或者位图索引等。</li>
</ul>
<h3 id="创建索引的语法"><a href="#创建索引的语法" class="headerlink" title="创建索引的语法"></a>创建索引的语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [TEMPORARY] [<span class="keyword">EXTERNAL</span>] INDEX index_name <span class="keyword">ON</span> <span class="keyword">TABLE</span> table_name (column_name,...) </span><br><span class="line"><span class="keyword">AS</span> <span class="string">&#x27;index_handler_class&#x27;</span> </span><br><span class="line">[<span class="keyword">WITH</span> DEFERRED REBUILD] </span><br><span class="line">[TBLPROPERTIES (<span class="string">&#x27;key&#x27;</span><span class="operator">=</span><span class="string">&#x27;value&#x27;</span>, ...)] </span><br><span class="line">[<span class="keyword">IN</span> <span class="keyword">TABLE</span> table_name] </span><br><span class="line">[PARTITIONED <span class="keyword">BY</span> (col_name data_type [COMMENT col_comment], ...)] </span><br><span class="line">[COMMENT index_comment];</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>TEMPORARY</code>表示创建一个临时索引，会话结束后自动删除；</li>
<li><code>EXTERNAL</code>表示创建一个外部索引，不会随着表的删除而删除；</li>
<li><code>index_handler_class</code>表示用于创建索引的处理器类，可以是内置的或者自定义的；</li>
<li><code>WITH DEFERRED REBUILD</code>表示创建一个空索引，可以在之后使用<code>ALTER INDEX ... REBUILD</code>语句来重建索引数据；</li>
<li><code>TBLPROPERTIES</code>表示指定一些索引属性，例如创建者、创建时间等；</li>
<li><code>IN TABLE table_name</code>表示指定存放索引数据的表名，如果不指定则默认为原表名加上后缀“_index”；</li>
<li><code>PARTITIONED BY</code>表示指定分区列，如果不指定则默认和原表分区一致；</li>
<li><code>COMMENT index_comment</code>表示添加一些注释说明。</li>
</ul>
<p>例如，为employees表的country列创建一个内置的紧凑型索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX employees_index <span class="keyword">ON</span> <span class="keyword">TABLE</span> employees(country) <span class="keyword">AS</span> <span class="string">&#x27;org.apache.hadoop.hive.ql.index.compact.CompactIndexHandler&#x27;</span> <span class="keyword">WITH</span> DEFERRED REBUILD <span class="keyword">IN</span> <span class="keyword">TABLE</span> employees_index_table PARTITIONED <span class="keyword">BY</span> (country,name) COMMENT <span class="string">&#x27;Employees indexed by country and name&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>创建完索引后需要重建索引数据才能生效，使用语句：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> INDEX index_name <span class="keyword">ON</span> <span class="keyword">TABLE</span> table_name <span class="keyword">PARTITION</span>(partition_spec) REBUILD;</span><br></pre></td></tr></table></figure>

<ul>
<li>Hive没有提供一个内置的在数据变更时自动触发创建索引的机制，因此用户需要自己通过上述语句来重建索引；</li>
<li>重建索引操作是一个原子操作，因此当rebuild失败时，已创建的索引也无法使用；</li>
<li>Hive中的索引功能还比较有限，并不适用于所有场景和查询。用户可以使用EXPLAIN语法来分析HiveQL语句是否可以使用索引来提升查询性能。</li>
</ul>
<h2 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h2><p>有一些其他的方法可以加快查询速度，例如：</p>
<ul>
<li>使用Tez引擎代替MapReduce引擎，Tez可以提高处理速度和保持MapReduce的扩展性；</li>
<li>使用向量化查询，向量化查询可以通过一次获取多行数据而不是单行数据来减少CPU的使用；</li>
<li>使用ORCFile格式存储表，ORCFile格式可以提供谓词下推、压缩等技术来减少I&#x2F;O消耗和存储空间；</li>
<li>使用分区和分桶技术，分区和分桶技术可以将数据按照某些列的值划分为不同的文件夹或文件，从而缩小查询范围和提高并行度；</li>
</ul>
<h1 id="HDFS不支持修改操作，hive是怎么实现update等操作的"><a href="#HDFS不支持修改操作，hive是怎么实现update等操作的" class="headerlink" title="HDFS不支持修改操作，hive是怎么实现update等操作的"></a>HDFS不支持修改操作，hive是怎么实现update等操作的</h1><p>由于HDFS不支持随机修改操作，所以Hive也不支持对数据的直接更新和删除。 但是，Hive提供了一些方法来实现数据的修改，主要有以下几种：</p>
<ul>
<li>使用INSERT OVERWRITE TABLE命令，将修改后的数据覆盖到原表或者分区上。</li>
<li>使用ALTER TABLE命令，修改表或者分区的属性、名称、字段、存储路径等元数据信息。</li>
<li>使用LOAD DATA命令，将外部文件加载到表或者分区中。</li>
<li>如果使用了ORC格式存储数据，并且开启了事务功能（transactional&#x3D;true），则可以使用UPDATE和DELETE命令来修改数据。</li>
</ul>
<p>这些方法都有一定的局限性和性能开销，所以一般不建议在Hive中频繁修改数据。</p>
<h2 id="UPDATE是怎么实现的"><a href="#UPDATE是怎么实现的" class="headerlink" title="UPDATE是怎么实现的"></a>UPDATE是怎么实现的</h2><p>UPDATE命令是Hive在0.11版本之后提供的一种数据更新操作，它需要满足以下条件：</p>
<ul>
<li>表必须使用ORC格式存储；</li>
<li>表必须设置事务属性为true（transactional&#x3D;true）；</li>
<li>表必须是分桶表（bucketed table）；</li>
<li>Hive必须开启事务管理器（hive.txn.manager&#x3D;org.apache.hadoop.hive.ql.lockmgr.DbTxnManager）。</li>
</ul>
<p>UPDATE命令的底层实现原理是基于ORC文件格式的特性，利用ACID输出格式（AcidOutputFormat）和ACID合并操作符（AcidMergeOperator）来完成的。</p>
<p>具体来说，当执行UPDATE命令时，Hive会将原表中需要更新的数据行标记为删除，并将新的数据行写入到一个临时目录中。然后，Hive会启动一个后台线程，定期扫描这些临时目录，并将其与原表中的数据进行合并。合并过程中，会忽略被标记为删除的数据行，并将新的数据行覆盖到原位置。这样就实现了数据的更新操作。</p>
<p>这种实现方式有以下优点：</p>
<ul>
<li>不需要重写整个表或者分区，只需要处理被更新的数据行；</li>
<li>不需要锁定整个表或者分区，只需要锁定被更新的桶文件；</li>
<li>不影响其他查询对表或者分区的读取，保证了一致性和隔离性。</li>
</ul>
<p>但也有以下缺点：</p>
<ul>
<li>需要额外的存储空间和计算资源来处理临时目录和合并操作；</li>
<li>需要定期进行压缩和清理操作来回收空间和提高效率；</li>
<li>只支持ORC格式和分桶表，不支持其他格式和非分桶表。</li>
</ul>
<h3 id="为什么UPDATE操作只能在ORC格式的分桶表上执行"><a href="#为什么UPDATE操作只能在ORC格式的分桶表上执行" class="headerlink" title="为什么UPDATE操作只能在ORC格式的分桶表上执行"></a>为什么UPDATE操作只能在ORC格式的分桶表上执行</h3><p>这是因为UPDATE操作的底层实现原理依赖于ORC格式和分桶表的特性。</p>
<ul>
<li>ORC格式可以支持ACID输出格式（AcidOutputFormat）和ACID合并操作符（AcidMergeOperator），这两个组件是实现数据更新和删除操作的关键；</li>
<li>ORC格式可以保存多层级的统计信息，利用这些信息可以实现谓词下推和跳过不必要的数据，提高更新效率；</li>
<li>分桶表可以保证每个桶文件中数据行的顺序一致，方便进行锁定和合并操作；</li>
<li>分桶表可以避免产生过多或过少的小文件，影响HDFS性能。</li>
</ul>
<p>如果使用其他格式或非分桶表，就无法利用这些特性来实现高效、安全、一致的数据更新和删除操作。</p>
<h1 id="Hive提供的两个服务"><a href="#Hive提供的两个服务" class="headerlink" title="Hive提供的两个服务"></a>Hive提供的两个服务</h1><h2 id="HiveServer"><a href="#HiveServer" class="headerlink" title="HiveServer"></a>HiveServer</h2><p>用户可以远程将SQL提交到hive中去执行，并返回结果给用户</p>
<h2 id="MetaStore"><a href="#MetaStore" class="headerlink" title="MetaStore"></a>MetaStore</h2><p>负责存储和管理元数据的服务，它使用关系型数据库来保存元数据信息，例如数据库名，表名，列名等。</p>
<h2 id="配置和启动这两个服务"><a href="#配置和启动这两个服务" class="headerlink" title="配置和启动这两个服务"></a>配置和启动这两个服务</h2><p>配置和启动hive server和hive metastore的步骤大致如下：</p>
<ul>
<li>安装mysql server，并设置用户名和密码</li>
<li>安装mysql java connector，并创建软链接到hive lib目录</li>
<li>在mysql中创建一个数据库，例如hive_db，用来存储元数据</li>
<li>在hive-site.xml中配置以下属性：<ul>
<li>hive.metastore.uris：指定metastore的连接地址，例如thrift:&#x2F;&#x2F;localhost:9083</li>
<li>javax.jdo.option.ConnectionURL：指定metastore的数据库连接URL，例如jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;hive_db?createDatabaseIfNotExist&#x3D;true</li>
<li>javax.jdo.option.ConnectionDriverName：指定metastore的数据库驱动名，例如com.mysql.jdbc.Driver</li>
<li>javax.jdo.option.ConnectionUserName：指定metastore的数据库用户名，例如hiveuser</li>
<li>javax.jdo.option.ConnectionPassword：指定metastore的数据库密码，例如hivepassword</li>
</ul>
</li>
<li>启动hive metastore服务，使用命令nohup hive –service metastore &amp;</li>
<li>启动hive server服务，使用命令nohup hive –service hiveserver2 &amp;</li>
</ul>
<h1 id="beeline"><a href="#beeline" class="headerlink" title="beeline"></a>beeline</h1><p>beeline是一个基于JDBC的命令行客户端，它可以用来连接和操作hive server。beeline支持嵌入式模式和远程模式。在嵌入式模式下，它运行一个嵌入式的hive（类似于hive cli）；在远程模式下，它通过thrift协议连接到一个单独的hive server2进程。beeline可以执行hql语句，查看表结构，管理用户变量等功能。</p>
<p>连接方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beeline </span><br><span class="line">!connect jdbs:hive2//此处是启动了HiveServer的主机名:10000</span><br><span class="line"><span class="comment">#感叹号表示这是一个beeline命令，而非HQL语句</span></span><br></pre></td></tr></table></figure>

<h1 id="Hive中可以存储的数据类型"><a href="#Hive中可以存储的数据类型" class="headerlink" title="Hive中可以存储的数据类型"></a>Hive中可以存储的数据类型</h1><ul>
<li>基本数据类型，包括整型（TINYINT、SMALLINT、INT、BIGINT）、浮点型（FLOAT、DOUBLE）、定点数（DECIMAL）、布尔型（BOOLEAN）、二进制型（BINARY）、字符串型（STRING、VARCHAR、CHAR）和日期时间型（TIMESTAMP、DATE）。</li>
<li>复合数据类型，包括数组（ARRAY）、映射（MAP）、结构体（STRUCT）和联合体（UNIONTYPE）。</li>
</ul>
<h2 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个包含数组的表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> arr1(</span><br><span class="line">  name string,</span><br><span class="line">  score <span class="keyword">array</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span></span><br><span class="line">) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27; &#x27;</span> collection items terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 加载数据</span></span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/home/hivedata/arr1&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> arr1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> arr1;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> score               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> goudan <span class="operator">|</span> [<span class="number">60</span>,<span class="number">20</span>,<span class="number">10</span>]          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mazi   <span class="operator">|</span> [<span class="number">90</span>,<span class="number">30</span>,<span class="number">20</span>]          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> haoge  <span class="operator">|</span> [<span class="number">15</span>,<span class="number">9</span>,<span class="number">20</span>]           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cg     <span class="operator">|</span> [<span class="number">59</span>,<span class="number">151</span>]            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数组中的第一个元素</span></span><br><span class="line"><span class="keyword">select</span> name, score[<span class="number">0</span>] <span class="keyword">from</span> arr1;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> _c1   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+</span></span><br><span class="line"><span class="operator">|</span> goudan <span class="operator">|</span> <span class="number">60</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mazi   <span class="operator">|</span> <span class="number">90</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> haoge  <span class="operator">|</span> <span class="number">15</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cg     <span class="operator">|</span> <span class="number">59</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数组中是否包含某个元素</span></span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> arr1 <span class="keyword">where</span> array_contains(score, <span class="number">90</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> mazi   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br></pre></td></tr></table></figure>



<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个包含映射的表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> map1(</span><br><span class="line">  id <span class="type">int</span>,</span><br><span class="line">  info map<span class="operator">&lt;</span>string,string<span class="operator">&gt;</span></span><br><span class="line">) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27; &#x27;</span> collection items terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> map keys terminated <span class="keyword">by</span> <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 加载数据</span></span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/home/hivedata/map1&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> map1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> map1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id<span class="operator">|</span> info                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> &#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:&quot;18&quot;&#125;       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span> &#123;&quot;name&quot;:&quot;Bob&quot;,&quot;gender&quot;:&quot;male&quot;&#125;    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span> &#123;&quot;name&quot;:&quot;Charlie&quot;,&quot;hobby&quot;:&quot;music&quot;&#125;<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+------------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询映射中的某个键对应的值</span></span><br><span class="line"><span class="keyword">select</span> id, info[&quot;name&quot;] <span class="keyword">from</span> map1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+-------+</span></span><br><span class="line"><span class="operator">|</span> id<span class="operator">|</span> _c1   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+- -----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> Alice <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span> Bob   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span> Charlie<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="operator">-</span> <span class="comment">--+- -----+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询映射中所有的键或值</span></span><br><span class="line"><span class="keyword">select</span> id, map_keys(info), map_values(info) <span class="keyword">from</span> map1;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id<span class="operator">|</span> _c1               <span class="operator">|</span> _c2</span><br><span class="line"><span class="operator">+</span><span class="comment">---+----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> [&quot;name&quot;,&quot;age&quot;]    <span class="operator">|</span> [&quot;Alice&quot;,&quot;18&quot;]     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span> [&quot;name&quot;,&quot;gender&quot;] <span class="operator">|</span> [&quot;Bob&quot;,&quot;male&quot;]     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span> [&quot;name&quot;,&quot;hobby&quot;]  <span class="operator">|</span> [&quot;Charlie&quot;,&quot;music&quot;]<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+----------------------------------------+</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询映射中是否包含某个键或值</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> map1 <span class="keyword">where</span> array_contains(map_keys(info), &quot;gender&quot;);</span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> id<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br></pre></td></tr></table></figure>



<h3 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h3><p>结构体（STRUCT）是一种基于对象的数据结构形式，它可以包含不同类型的字段，每个字段都有一个名称和一个值。例如，表中一列user的类型为STRUCT{name string; age int}，我们可以通过user.name来访问域name。</p>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个包含结构体的表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> str1(</span><br><span class="line">  name string,</span><br><span class="line">  score struct<span class="operator">&lt;</span>chinese:<span class="type">int</span>,math:<span class="type">int</span>,english:<span class="type">int</span><span class="operator">&gt;</span></span><br><span class="line">) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27; &#x27;</span> collection items terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 加载数据</span></span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/home/hivedata/str&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> str1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> str1;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> score               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> goudan <span class="operator">|</span> &#123;<span class="number">60</span>,<span class="number">20</span>,<span class="number">10</span>&#125;          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mazi   <span class="operator">|</span> &#123;<span class="number">90</span>,<span class="number">30</span>,<span class="number">20</span>&#125;          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> haoge  <span class="operator">|</span> &#123;<span class="number">15</span>,<span class="number">9</span>,<span class="number">20</span>&#125;           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cg     <span class="operator">|</span> &#123;<span class="number">59</span>,<span class="number">151</span>&#125;            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+---------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询英语成绩不为空的姓名和总分</span></span><br><span class="line"><span class="keyword">select</span> s.name, s.score.chinese <span class="operator">+</span> s.score.math <span class="operator">+</span> s.score.english <span class="keyword">as</span> total <span class="keyword">from</span> str1 s <span class="keyword">where</span> s.score.english <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> total <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+</span></span><br><span class="line"><span class="operator">|</span> goudan <span class="operator">|</span> <span class="number">90</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mazi   <span class="operator">|</span> <span class="number">140</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> haoge  <span class="operator">|</span> <span class="number">44</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------+</span></span><br></pre></td></tr></table></figure>



<h3 id="UnionType"><a href="#UnionType" class="headerlink" title="UnionType"></a>UnionType</h3><p>联合体（UNIONTYPE）是一种异质的数据类型的集合，它可以存储不同类型的值，但是每次只能存储一个值。例如，表中一列value的类型为UNIONTYPE&lt;int, double, array&lt;string&gt;, struct&lt;a:int,b:string&gt;&gt;，我们可以通过value.tag来获取当前值的类型标签（0表示int，1表示double，2表示array&lt;string&gt;，3表示struct&lt;a:int,b:string&gt;），然后通过value.value来获取当前值。</p>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个包含联合体的表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> uni1(</span><br><span class="line">  <span class="keyword">value</span> UNIONTYPE<span class="operator">&lt;</span><span class="type">int</span>,<span class="keyword">double</span>,<span class="keyword">array</span><span class="operator">&lt;</span>string<span class="operator">&gt;</span>,struct<span class="operator">&lt;</span>a:<span class="type">int</span>,b:string<span class="operator">&gt;&gt;</span></span><br><span class="line">) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27; &#x27;</span> collection items terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> map keys terminated <span class="keyword">by</span> <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 加载数据</span></span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;/home/hivedata/uni&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> uni1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> uni1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">value</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br><span class="line"><span class="operator">|</span> &#123;<span class="number">0</span>:<span class="number">1</span>&#125;                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> &#123;<span class="number">1</span>:<span class="number">2.0</span>&#125;              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> &#123;<span class="number">2</span>:[&quot;three&quot;,&quot;four&quot;]&#125; <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> &#123;<span class="number">3</span>:&#123;&quot;a&quot;:<span class="number">5</span>,&quot;b&quot;:&quot;five&quot;&#125;&#125;<span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> &#123;<span class="number">2</span>:[&quot;six&quot;,&quot;seven&quot;]&#125;  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> &#123;<span class="number">3</span>:&#123;&quot;a&quot;:<span class="number">8</span>,&quot;b&quot;:&quot;eight&quot;&#125;&#125;<span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> &#123;<span class="number">0</span>:<span class="number">9</span>&#125;                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> &#123;<span class="number">1</span>:<span class="number">10.0</span>&#125;             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询当前值为数组类型的元素个数和第一个元素</span></span><br><span class="line"><span class="keyword">select</span> size(value.value), value.value[<span class="number">0</span>] <span class="keyword">from</span> uni1 <span class="keyword">where</span> value.tag <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------------+</span></span><br><span class="line"><span class="operator">|</span> _c0  <span class="operator">|</span> _c1        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span> three      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span> six        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------------+</span></span><br></pre></td></tr></table></figure>



<h1 id="HQL"><a href="#HQL" class="headerlink" title="HQL"></a>HQL</h1><h2 id="order-by-与-sort-by"><a href="#order-by-与-sort-by" class="headerlink" title="order by 与 sort by"></a>order by 与 sort by</h2><ul>
<li>Hive会将order by语句转换为一个mapreduce任务，其中只有一个reducer负责对所有的mapper输出进行排序和输出。</li>
<li><strong>这意味着order by语句会将所有的数据发送到一个reducer上，这会导致性能低下和内存不足的问题，尤其是当表的数据量很大时。</strong></li>
<li>为了解决这个问题，Hive提供了sort by语句，它可以使用多个reducer来对数据进行局部排序。</li>
<li>sort by语句会根据partitioner（默认是HashPartitioner）将数据分配到不同的reducer上，每个reducer会对自己的输入进行排序和输出²。</li>
<li>这样可以提高排序的效率，但是不能保证全局有序，因为不同的reducer之间没有进行排序。</li>
</ul>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>查看内置函数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> functionsl; # 查看函数列表</span><br><span class="line"><span class="keyword">desc</span> <span class="keyword">function</span> 函数名; # 查看具体的函数描述</span><br><span class="line"><span class="keyword">desc</span> <span class="keyword">function</span> extended 函数名; # 查看函数使用文档</span><br></pre></td></tr></table></figure>

<h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/130327069">hive的窗口函数详解 - 知乎 (zhihu.com)</a></p>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><h3 id="UDF"><a href="#UDF" class="headerlink" title="UDF"></a>UDF</h3><p>用户自定义函数（User Defined Function）</p>
<p>一进一出</p>
<h3 id="UDTF"><a href="#UDTF" class="headerlink" title="UDTF"></a>UDTF</h3><p>用户自定义表生成函数（User Defined Table-Generating Function）</p>
<p>一进多出</p>
<h3 id="UDAF"><a href="#UDAF" class="headerlink" title="UDAF"></a>UDAF</h3><p>用户自定义聚合函数（User Defined Aggregation Function）</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>有两个包可以用</p>
<ul>
<li><code>org.apache.hadoop.hive.ql.exec</code></li>
<li><code>org.apache.hadoop.hive.ql.udf.generic</code></li>
</ul>
<p><code>org.apache.hadoop.hive.ql.exec</code>包中的<code>UDF</code>、<code>UDTF</code>、<code>UDAFEvaluator</code>等类已经被废弃，不推荐使用，而推荐使用<code>org.apache.hadoop.hive.ql.udf.generic</code>包中的<code>GenericUDF</code>、<code>GenericUDTF</code>、<code>GenericUDAFEvaluator</code>等类；</p>
<p><code>org.apache.hadoop.hive.ql.udf.generic</code>包中的类可以处理复杂的数据类型，并提供更高的效率，而<code>org.apache.hadoop.hive.ql.exec</code>包中的类只能处理简单的数据类型，并且需要使用反射机制；</p>
<p>因此，<code>org.apache.hadoop.hive.ql.udf.generic</code>包是Hive中用户自定义函数开发的推荐方式。</p>
<p>步骤：</p>
<ul>
<li>使用Maven创建一个Java或Scala项目，添加hive-exec的依赖。</li>
<li>继承对应的类，重写对应的方法，实现自定义的逻辑。</li>
<li>打包成jar文件，上传到Hive服务器。</li>
<li>在Hive命令行中，使用add jar命令添加jar文件。</li>
<li>使用create function命令注册自定义函数，指定包名和类名。</li>
<li>使用select语句调用自定义函数，传入参数。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> Hive命令行</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 添加jar文件</span><br><span class="line"><span class="keyword">add</span> jar <span class="operator">/</span>xxx<span class="operator">/</span>xxx<span class="operator">/</span>xxx<span class="operator">/</span>xxx.jar;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 注册函数</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> [函数名] <span class="keyword">as</span> <span class="string">&#x27;[包名].[类名]&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 注册临时函数</span><br><span class="line"><span class="keyword">create</span> temporary <span class="keyword">function</span> [函数名] <span class="keyword">as</span> <span class="string">&#x27;[包名].[类名]&#x27;</span>;</span><br></pre></td></tr></table></figure>





<h1 id="Hive使用不同计算引擎的区别"><a href="#Hive使用不同计算引擎的区别" class="headerlink" title="Hive使用不同计算引擎的区别"></a>Hive使用不同计算引擎的区别</h1><p>Hive可以使用不同的计算引擎来执行HQL语句，包括MapReduce、Spark、Tez等。不同的计算引擎有各自的优势和局限性。</p>
<p>Hive使用MapReduce作为计算引擎的优势：</p>
<ul>
<li>MapReduce是Hadoop的原生计算框架，与HDFS有良好的兼容性和稳定性。</li>
<li>MapReduce适合处理大规模数据，可以利用磁盘进行数据交换，避免内存溢出。</li>
<li>MapReduce支持多种编程语言，如Java、Python、Ruby等。</li>
</ul>
<p>Hive使用Spark作为计算引擎的优势：</p>
<ul>
<li>Spark是基于内存的分布式计算框架，相比MapReduce有更高的执行效率和更低的延迟。</li>
<li>Spark支持多种高级抽象，如DataFrame、DataSet、MLlib等，可以实现更复杂的数据分析和机器学习任务。</li>
<li>Spark支持动态资源分配，可以根据任务需求灵活调整资源使用。</li>
</ul>
<h1 id="Spark-on-Hive-和-Hive-on-Spark"><a href="#Spark-on-Hive-和-Hive-on-Spark" class="headerlink" title="Spark on Hive 和 Hive on Spark"></a>Spark on Hive 和 Hive on Spark</h1><p>hive on spark是指把spark作为hive的计算引擎。这种模式下，数据是存储在hive中的，用户使用hql来处理和分析数据，但底层会通过spark来执行。</p>
<p>spark on hive是指使用spark来处理存储在hive中的数据，用户可以使用spark的api或sql来进行分析。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><p>配置方式：</p>
<ul>
<li>spark on hive只需要配置spark和hive的相关参数，不需要重新编译spark或者hive；</li>
<li>hive on spark需要重新编译hive，并且将spark的jar包放到hive的lib目录下。</li>
</ul>
</li>
<li><p>兼容性：</p>
<ul>
<li>spark on hive可以兼容多个版本的hive和spark，只要保证数据源和sql语法的一致性；</li>
<li>hive on spark只能兼容特定版本的hive和spark，因为不同版本之间可能存在接口或者功能上的差异。</li>
</ul>
</li>
<li><p>功能支持：</p>
<ul>
<li>spark on hive可以支持更多的数据源和文件格式，例如parquet, orc, delta lake等。同时，spark on hive也可以支持更多的高级功能，例如机器学习，图计算等；</li>
<li>hive on spark目前还不支持delta lake等新型文件格式，hive on spark主要是针对批处理场景进行优化。</li>
</ul>
</li>
<li><p>数据存储：</p>
<ul>
<li>spark on hive是使用spark来处理存储在hive中的数据，数据以表的形式存储在hive中；</li>
<li>hive on spark是使用hive来处理和分析数据，但底层使用spark作为计算引擎，数据也可以存储在其他支持hadoop的文件系统或数据库中。</li>
</ul>
</li>
<li><p>语言选择：</p>
<ul>
<li>spark on hive可以使用spark的api或sql来进行分析，也可以使用hive语法规范的hql；</li>
<li>hive on spark只能使用hql来进行分析。</li>
</ul>
</li>
<li><p>执行流程：</p>
<ul>
<li>spark on hive是将sql或hql转换为spark作业来运行，不需要经过mapreduce；</li>
<li>hive on spark是将hql经过hive的解析优化编译后转换为spark作业来运行，也不需要经过mapreduce。</li>
</ul>
</li>
<li><p>性能差异：</p>
<p>spark on hive和hive on spark都比原生的hive on mapreduce有更快的性能，但具体哪个更快要根据具体的场景和配置来判断。一般来说，如果查询涉及到多个表或多个阶段，则hive on spark会比较快；如果查询只涉及到单表或单阶段，则spark on hive会比较快。</p>
<p>涉及多表时hive on spark更快，是因为hive可以对hql进行更好的解析优化和编译，生成更高效的spark作业；而涉及单表时spark on hive更快，是因为spark可以对sql或api进行更好的执行优化和调度，减少中间数据的传输和存储。</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">62bit</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/02/20/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2023/02/20/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">62bit的秘密基地</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/favicon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/22/%E5%85%B3%E4%BA%8E%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E6%91%84%E5%83%8F%E5%A4%B4%E6%98%BE%E7%A4%BA%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C%E5%8D%B4%E6%B2%A1%E6%9C%89%E5%9B%BE%E5%83%8F%E7%9A%84%E9%97%AE%E9%A2%98/" title="关于笔记本电脑摄像头显示正常工作却没有图像的问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">关于笔记本电脑摄像头显示正常工作却没有图像的问题</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/16/%E5%85%B3%E4%BA%8E-IntelliJ-Maven-error-Repository-is-non-nexus-repo-or-is-not-indexed-remote-update-error-%E7%9A%84%E9%97%AE%E9%A2%98/" title="关于 IntelliJ Maven error: Repository is non-nexus repo, or is not indexed (remote update error) 的问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">关于 IntelliJ Maven error: Repository is non-nexus repo, or is not indexed (remote update error) 的问题</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">62bit</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/62bit"><i class="fab fa-github"></i><span>My Github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">江苏科技大学某不知名菜鸟的个人博客
喜欢术力口和跳舞的准程序猿</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">数据仓库和数据库的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%8C%83%E5%BC%8F%E5%8C%96%E7%9A%84%E8%A1%A8%E7%BB%93%E6%9E%84%EF%BC%88Denormalized%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">反范式化的表结构（Denormalized）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">多维表结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hive%E7%9A%84%E5%87%BA%E7%8E%B0%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">Hive的出现解决了什么问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hive%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">Hive的架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8A%8Ahive%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E4%BF%9D%E5%AD%98%E5%9C%A8hdfs%E4%B8%8A"><span class="toc-number">3.1.</span> <span class="toc-text">为什么不把hive的元数据信息保存在hdfs上</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%A1%B6%E8%A1%A8%E3%80%81%E5%88%86%E5%8C%BA%E8%A1%A8%E3%80%81%E5%86%85%E9%83%A8%E8%A1%A8%E5%92%8C%E5%A4%96%E9%83%A8%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">分桶表、分区表、内部表和外部表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%A1%B6%E8%A1%A8"><span class="toc-number">4.1.</span> <span class="toc-text">分桶表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E6%A1%B6%E5%8F%AF%E4%BB%A5%E6%8F%90%E9%AB%98join%E6%95%88%E7%8E%87"><span class="toc-number">4.1.1.</span> <span class="toc-text">为什么分桶可以提高join效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%90%8E%E5%88%86%E6%A1%B6%E5%92%8C%E7%BB%84%E5%90%88%E5%88%86%E6%A1%B6"><span class="toc-number">4.1.2.</span> <span class="toc-text">先后分桶和组合分桶</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-number">4.2.</span> <span class="toc-text">分区表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%AD%97%E6%AE%B5%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%97%E6%AE%B5"><span class="toc-number">4.2.1.</span> <span class="toc-text">分区字段和数据字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E5%8C%BA%E5%92%8C%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA"><span class="toc-number">4.2.2.</span> <span class="toc-text">静态分区和动态分区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%A1%B6%E5%92%8C%E5%88%86%E5%8C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">分桶和分区的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E8%A1%A8%E5%92%8C%E5%A4%96%E9%83%A8%E8%A1%A8"><span class="toc-number">4.4.</span> <span class="toc-text">内部表和外部表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E7%94%A8%E5%88%B0msck-repair-table-table-name%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.5.</span> <span class="toc-text">什么时候会用到msck repair table table_name语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hive%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9"><span class="toc-number">5.</span> <span class="toc-text">Hive表的数据压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E6%A0%87"><span class="toc-number">5.1.</span> <span class="toc-text">指标</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hive%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">Hive表的存储格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">6.1.</span> <span class="toc-text">行式存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">6.2.</span> <span class="toc-text">列式存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">6.3.</span> <span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#hive%E4%B8%AD%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E4%B8%80%E5%BC%A0%E8%A1%A8%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">hive中将数据导入一张表中有哪些方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hive%E6%98%AF%E6%80%8E%E4%B9%88%E6%8A%8AHQL%E8%AF%AD%E5%8F%A5%E8%BD%AC%E4%B8%BAMR%E4%BB%BB%E5%8A%A1%E7%9A%84"><span class="toc-number">8.</span> <span class="toc-text">Hive是怎么把HQL语句转为MR任务的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hive%E6%80%8E%E4%B9%88%E5%8A%A0%E5%BF%AB%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6"><span class="toc-number">9.</span> <span class="toc-text">Hive怎么加快查询速度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hive%E6%94%AF%E6%8C%81%E7%B4%A2%E5%BC%95%E5%90%97"><span class="toc-number">9.1.</span> <span class="toc-text">Hive支持索引吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">9.1.1.</span> <span class="toc-text">创建索引的语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">其他方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HDFS%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C%EF%BC%8Chive%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0update%E7%AD%89%E6%93%8D%E4%BD%9C%E7%9A%84"><span class="toc-number">10.</span> <span class="toc-text">HDFS不支持修改操作，hive是怎么实现update等操作的</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UPDATE%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">10.1.</span> <span class="toc-text">UPDATE是怎么实现的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88UPDATE%E6%93%8D%E4%BD%9C%E5%8F%AA%E8%83%BD%E5%9C%A8ORC%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%88%86%E6%A1%B6%E8%A1%A8%E4%B8%8A%E6%89%A7%E8%A1%8C"><span class="toc-number">10.1.1.</span> <span class="toc-text">为什么UPDATE操作只能在ORC格式的分桶表上执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hive%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%9C%8D%E5%8A%A1"><span class="toc-number">11.</span> <span class="toc-text">Hive提供的两个服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HiveServer"><span class="toc-number">11.1.</span> <span class="toc-text">HiveServer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MetaStore"><span class="toc-number">11.2.</span> <span class="toc-text">MetaStore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%92%8C%E5%90%AF%E5%8A%A8%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%9C%8D%E5%8A%A1"><span class="toc-number">11.3.</span> <span class="toc-text">配置和启动这两个服务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#beeline"><span class="toc-number">12.</span> <span class="toc-text">beeline</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hive%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">13.</span> <span class="toc-text">Hive中可以存储的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">13.1.</span> <span class="toc-text">复合数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Array"><span class="toc-number">13.1.1.</span> <span class="toc-text">Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">13.1.2.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Struct"><span class="toc-number">13.1.3.</span> <span class="toc-text">Struct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UnionType"><span class="toc-number">13.1.4.</span> <span class="toc-text">UnionType</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HQL"><span class="toc-number">14.</span> <span class="toc-text">HQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#order-by-%E4%B8%8E-sort-by"><span class="toc-number">14.1.</span> <span class="toc-text">order by 与 sort by</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">14.2.</span> <span class="toc-text">内置函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">14.2.1.</span> <span class="toc-text">窗口函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">14.3.</span> <span class="toc-text">自定义函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDF"><span class="toc-number">14.3.1.</span> <span class="toc-text">UDF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDTF"><span class="toc-number">14.3.2.</span> <span class="toc-text">UDTF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDAF"><span class="toc-number">14.3.3.</span> <span class="toc-text">UDAF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">14.3.4.</span> <span class="toc-text">例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hive%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.</span> <span class="toc-text">Hive使用不同计算引擎的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spark-on-Hive-%E5%92%8C-Hive-on-Spark"><span class="toc-number">16.</span> <span class="toc-text">Spark on Hive 和 Hive on Spark</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">16.1.</span> <span class="toc-text">区别</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/13/Stable-Diffusion-AI%E7%BB%98%E7%94%BB%E5%88%9D%E4%BD%93%E9%AA%8C/" title="Stable Diffusion AI绘画初体验">Stable Diffusion AI绘画初体验</a><time datetime="2023-09-13T03:06:22.000Z" title="发表于 2023-09-13 11:06:22">2023-09-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/08/%E5%A6%82%E4%BD%95%E8%AE%B0%E7%AC%94%E8%AE%B0/" title="如何记笔记">如何记笔记</a><time datetime="2023-09-08T06:10:21.000Z" title="发表于 2023-09-08 14:10:21">2023-09-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/08/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%80%9D%E7%BB%B4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="数据分析思维学习笔记">数据分析思维学习笔记</a><time datetime="2023-09-08T01:39:32.000Z" title="发表于 2023-09-08 09:39:32">2023-09-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/20/%E9%9D%A2%E8%AF%95%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AAJava%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/" title="面试中遇到的一个Java基础问题">面试中遇到的一个Java基础问题</a><time datetime="2023-03-20T09:30:50.000Z" title="发表于 2023-03-20 17:30:50">2023-03-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/19/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B9%8BADS%E5%B1%82%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" title="数据仓库之ADS层数据可视化">数据仓库之ADS层数据可视化</a><time datetime="2023-03-19T07:36:31.000Z" title="发表于 2023-03-19 15:36:31">2023-03-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 62bit</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">谢谢你能够看到我!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>